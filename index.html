<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Fantasy Basketball Trade Machine</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
            }
            #upload {
                margin-bottom: 20px;
            }
            .team {
                border: 1px solid #ccc;
                padding: 10px;
                margin: 10px 0;
            }
            #trade-section {
                border: 1px solid #ddd;
                padding: 20px;
                margin-top: 20px;
            }
            table {
                border-collapse: collapse;
                margin: 10px 0;
            }
            th,
            td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }
            th {
                background-color: #f2f2f2;
            }
        </style>
    </head>
    <body>
        <div id="upload">
            <input type="file" id="csvFile" accept=".csv" />
            <button onclick="loadCSV()">Load CSV</button>
        </div>
        <div id="teams"></div>
        <div id="trade-section" style="display: none">
            <h2>Trade Machine</h2>
            <label for="num-teams">Trade Type:</label>
            <select id="num-teams">
                <option value="2">2-Way Trade</option>
                <option value="3">3-Way Trade</option>
            </select>
            <div id="team-selects"></div>
            <div id="player-selects"></div>
            <button onclick="analyzeTrade()">Analyze Trade</button>
            <div id="analysis"></div>
        </div>

        <script>
            let players = [];
            let teams = [];
            let data = {}; // team => array of players
            let league_fg = 0;
            let league_ft = 0;
            let z_means = {};
            let z_sds = {};

            function loadCSV() {
                const file = document.getElementById("csvFile").files[0];
                if (!file) {
                    alert("Please select a CSV file.");
                    return;
                }
                const reader = new FileReader();
                reader.onload = function (e) {
                    const text = e.target.result;
                    parseCSV(text);
                };
                reader.readAsText(file);
            }

            function parseCSV(text) {
                const lines = text.split(/\r?\n/);
                const headers = lines[0].split(",").map((h) => h.trim());
                players = [];
                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i].trim()) continue;
                    const values = lines[i].split(",").map((v) => v.trim());
                    const player = {};
                    for (let j = 0; j < headers.length; j++) {
                        player[headers[j]] = values[j];
                    }
                    // Convert numeric fields
                    [
                        "GP",
                        "MIN",
                        "FGM",
                        "FGA",
                        "FG%",
                        "FTM",
                        "FTA",
                        "FT%",
                        "3PTM",
                        "REB",
                        "AST",
                        "ST",
                        "BLK",
                        "TO",
                        "PTS",
                    ].forEach((key) => {
                        player[key] = parseFloat(player[key]) || 0;
                    });
                    players.push(player);
                }
                computeZscores();
                groupByTeams();
                displayTeams();
                document.getElementById("trade-section").style.display =
                    "block";
                updateTradeUI();
            }

            function computeZscores() {
                // Compute league-wide weighted percentages
                let total_fgm = 0,
                    total_fga = 0,
                    total_ftm = 0,
                    total_fta = 0;
                players.forEach((p) => {
                    total_fgm += p.FGM;
                    total_fga += p.FGA;
                    total_ftm += p.FTM;
                    total_fta += p.FTA;
                });
                league_fg = total_fga > 0 ? total_fgm / total_fga : 0.5;
                league_ft = total_fta > 0 ? total_ftm / total_fta : 0.8;

                // Collect data for means and sds
                let delta_fgms = [],
                    delta_ftms = [];
                let collects = {
                    PTS: [],
                    REB: [],
                    AST: [],
                    ST: [],
                    BLK: [],
                    "3PTM": [],
                    TO: [],
                    "FG%": [],
                    "FT%": [],
                };
                players.forEach((p) => {
                    const delta_fg = p.FGM - league_fg * p.FGA;
                    delta_fgms.push(delta_fg);
                    const delta_ft = p.FTM - league_ft * p.FTA;
                    delta_ftms.push(delta_ft);
                    Object.keys(collects).forEach((s) =>
                        collects[s].push(p[s]),
                    );
                });

                // Helper functions
                function mean(arr) {
                    return arr.reduce((a, b) => a + b, 0) / arr.length || 0;
                }
                function sd(arr, m = mean(arr)) {
                    return (
                        Math.sqrt(
                            arr.reduce((a, b) => a + (b - m) ** 2, 0) /
                                arr.length,
                        ) || 1
                    );
                }

                // Weighted (volume-adjusted)
                const mean_delta_fg = mean(delta_fgms);
                const sd_delta_fg = sd(delta_fgms, mean_delta_fg);
                const mean_delta_ft = mean(delta_ftms);
                const sd_delta_ft = sd(delta_ftms, mean_delta_ft);

                // Unweighted for percentages
                const mean_fg = mean(collects["FG%"]);
                const sd_fg = sd(collects["FG%"], mean_fg);
                const mean_ft = mean(collects["FT%"]);
                const sd_ft = sd(collects["FT%"], mean_ft);

                // Means and sds for counting stats
                ["PTS", "REB", "AST", "ST", "BLK", "3PTM", "TO"].forEach(
                    (s) => {
                        z_means[s] = mean(collects[s]);
                        z_sds[s] = sd(collects[s], z_means[s]);
                    },
                );

                // Assign z-scores to players
                players.forEach((p) => {
                    p.z = {};
                    ["PTS", "REB", "AST", "ST", "BLK", "3PTM"].forEach((s) => {
                        p.z[s] = (p[s] - z_means[s]) / z_sds[s];
                    });
                    p.z["TO"] = -(p["TO"] - z_means["TO"]) / z_sds["TO"];
                    // Unweighted %
                    p.z["FG%_unw"] = (p["FG%"] - mean_fg) / sd_fg;
                    p.z["FT%_unw"] = (p["FT%"] - mean_ft) / sd_ft;
                    // Weighted %
                    const delta_fg = p.FGM - league_fg * p.FGA;
                    p.z["FG%_w"] = (delta_fg - mean_delta_fg) / sd_delta_fg;
                    const delta_ft = p.FTM - league_ft * p.FTA;
                    p.z["FT%_w"] = (delta_ft - mean_delta_ft) / sd_delta_ft;
                    // Total z using weighted for %
                    p.total_z = 0;
                    [
                        "PTS",
                        "REB",
                        "AST",
                        "ST",
                        "BLK",
                        "3PTM",
                        "TO",
                        "FG%_w",
                        "FT%_w",
                    ].forEach((key) => {
                        p.total_z += p.z[key] || 0;
                    });
                });
            }

            function groupByTeams() {
                data = {};
                teams = [...new Set(players.map((p) => p.Status))].sort();
                teams.forEach((t) => (data[t] = []));
                players.forEach((p) => {
                    if (data[p.Status]) data[p.Status].push(p);
                });
            }

            function displayTeams() {
                const div = document.getElementById("teams");
                div.innerHTML = "";
                teams.forEach((t) => {
                    const teamDiv = document.createElement("div");
                    teamDiv.className = "team";
                    teamDiv.innerHTML = `<h3>${t}</h3>`;
                    const ul = document.createElement("ul");
                    data[t].forEach((p) => {
                        const li = document.createElement("li");
                        li.innerHTML = `${p.Player} (${p.Position}) - Total Z: ${p.total_z.toFixed(2)}<br>
                        FG% Z (unweighted): ${p.z["FG%_unw"].toFixed(2)}, (weighted): ${p.z["FG%_w"].toFixed(2)}<br>
                        FT% Z (unweighted): ${p.z["FT%_unw"].toFixed(2)}, (weighted): ${p.z["FT%_w"].toFixed(2)}`;
                        ul.appendChild(li);
                    });
                    teamDiv.appendChild(ul);
                    div.appendChild(teamDiv);
                });
                const exp = document.createElement("p");
                exp.innerHTML = `<strong>Explanation:</strong> Z-scores standardize player performance in each category. For FG% and FT%, the unweighted z-score is based solely on the percentage. The weighted z-score adjusts for volume (based on FGM/FTM and attempts), as a strong percentage on higher volume is more valuable to your team's overall stats. The total Z uses the weighted versions for percentages.`;
                div.appendChild(exp);
            }

            function updateTradeUI() {
                const num = parseInt(
                    document.getElementById("num-teams").value,
                );
                const ts = document.getElementById("team-selects");
                ts.innerHTML = "";
                const ps = document.getElementById("player-selects");
                ps.innerHTML = "";
                for (let i = 1; i <= num; i++) {
                    const label = document.createTextNode(
                        `Team ${String.fromCharCode(64 + i)}: `,
                    );
                    const select = document.createElement("select");
                    select.id = `team${i}`;
                    teams.forEach((t) => {
                        const opt = document.createElement("option");
                        opt.value = t;
                        opt.text = t;
                        select.appendChild(opt);
                    });
                    ts.appendChild(label);
                    ts.appendChild(select);
                    ts.appendChild(document.createElement("br"));
                    select.addEventListener("change", () =>
                        updatePlayerSelects(num),
                    );
                }
                updatePlayerSelects(num);
            }

            function updatePlayerSelects(num) {
                const ps = document.getElementById("player-selects");
                ps.innerHTML = "";
                for (let i = 1; i <= num; i++) {
                    const teamName = document.getElementById(`team${i}`).value;
                    const div = document.createElement("div");
                    div.innerHTML = `<h4>Players from ${teamName} to send:</h4>`;
                    const sel = document.createElement("select");
                    sel.id = `send${i}`;
                    sel.multiple = true;
                    sel.size = 5;
                    data[teamName].forEach((p) => {
                        const opt = document.createElement("option");
                        opt.value = p.ID;
                        opt.text = `${p.Player} (Z: ${p.total_z.toFixed(2)})`;
                        sel.appendChild(opt);
                    });
                    div.appendChild(sel);
                    ps.appendChild(div);
                }
            }

            document
                .getElementById("num-teams")
                .addEventListener("change", updateTradeUI);

            function analyzeTrade() {
                const num = parseInt(
                    document.getElementById("num-teams").value,
                );
                const involved = [];
                for (let i = 1; i <= num; i++) {
                    involved.push(document.getElementById(`team${i}`).value);
                }
                const sends = {};
                involved.forEach((t) => (sends[t] = []));
                for (let i = 1; i <= num; i++) {
                    const sel = document.getElementById(`send${i}`);
                    const team = involved[i - 1];
                    for (let opt of sel.options) {
                        if (opt.selected) {
                            const player = players.find(
                                (p) => p.ID == opt.value,
                            );
                            sends[team].push(player);
                        }
                    }
                }
                const receives = {};
                involved.forEach((t) => (receives[t] = []));
                for (let i = 0; i < num; i++) {
                    const sender = involved[i];
                    const receiver = involved[(i + 1) % num];
                    receives[receiver].push(...sends[sender]);
                }
                const analysisDiv = document.getElementById("analysis");
                analysisDiv.innerHTML = "";
                const cats = [
                    "FG%_w",
                    "FT%_w",
                    "3PTM",
                    "REB",
                    "AST",
                    "ST",
                    "BLK",
                    "TO",
                    "PTS",
                ];

                function getTeamStats(teamPlayers) {
                    let stats = {
                        FGM: 0,
                        FGA: 0,
                        FTM: 0,
                        FTA: 0,
                        "3PTM": 0,
                        REB: 0,
                        AST: 0,
                        ST: 0,
                        BLK: 0,
                        TO: 0,
                        PTS: 0,
                    };
                    teamPlayers.forEach((p) => {
                        Object.keys(stats).forEach((k) => (stats[k] += p[k]));
                    });
                    stats["FG%"] = stats.FGA > 0 ? stats.FGM / stats.FGA : 0;
                    stats["FT%"] = stats.FTA > 0 ? stats.FTM / stats.FTA : 0;
                    return stats;
                }

                involved.forEach((team) => {
                    const outgoing = sends[team];
                    const incoming = receives[team];
                    const currentPlayers = data[team].filter(
                        (p) => !outgoing.includes(p),
                    );
                    const newPlayers = [...currentPlayers, ...incoming];
                    const beforeStats = getTeamStats(data[team]);
                    const afterStats = getTeamStats(newPlayers);

                    // Net Z changes
                    const out_z = {};
                    const in_z = {};
                    cats.forEach((c) => {
                        out_z[c] = 0;
                        in_z[c] = 0;
                    });
                    outgoing.forEach((p) => {
                        cats.forEach(
                            (c) =>
                                (out_z[c] +=
                                    p.z[
                                        c === "FG%_w"
                                            ? "FG%_w"
                                            : c === "FT%_w"
                                              ? "FT%_w"
                                              : c
                                    ]),
                        );
                    });
                    incoming.forEach((p) => {
                        cats.forEach(
                            (c) =>
                                (in_z[c] +=
                                    p.z[
                                        c === "FG%_w"
                                            ? "FG%_w"
                                            : c === "FT%_w"
                                              ? "FT%_w"
                                              : c
                                    ]),
                        );
                    });
                    let net_total = 0;
                    let html = `<h3>Analysis for ${team}</h3>`;
                    html += `<h4>Net Z-Score Changes (using weighted for %)</h4>`;
                    html += `<table><tr><th>Category</th><th>Net Z Change</th></tr>`;
                    cats.forEach((c) => {
                        const net = in_z[c] - out_z[c];
                        net_total += net;
                        html += `<tr><td>${c}</td><td>${net.toFixed(2)}</td></tr>`;
                    });
                    html += `<tr><td>Total</td><td>${net_total.toFixed(2)}</td></tr></table>`;

                    // Before/After Stats
                    html += `<h4>Stat Changes</h4>`;
                    html += `<table><tr><th>Category</th><th>Before</th><th>After</th><th>Delta (positive = improvement)</th></tr>`;
                    [
                        "FG%",
                        "FT%",
                        "3PTM",
                        "REB",
                        "AST",
                        "ST",
                        "BLK",
                        "TO",
                        "PTS",
                    ].forEach((c) => {
                        let b =
                            c === "FG%" || c === "FT%"
                                ? beforeStats[c].toFixed(4)
                                : beforeStats[c].toFixed(1);
                        let a =
                            c === "FG%" || c === "FT%"
                                ? afterStats[c].toFixed(4)
                                : afterStats[c].toFixed(1);
                        let delta = a - b;
                        if (c === "TO") delta = beforeStats[c] - afterStats[c]; // Lower TO is better
                        html += `<tr><td>${c}</td><td>${b}</td><td>${a}</td><td>${delta.toFixed(4)}</td></tr>`;
                    });
                    html += `</table>`;
                    analysisDiv.innerHTML += html;
                });
            }
        </script>
    </body>
</html>
